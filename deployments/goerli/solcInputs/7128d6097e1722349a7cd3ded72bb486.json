{
  "language": "Solidity",
  "sources": {
    "@solidstate/contracts/access/ownable/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\n\ninterface IOwnable is IERC173 {}\n"
    },
    "@solidstate/contracts/access/ownable/IOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from '../../interfaces/IERC173Internal.sol';\n\ninterface IOwnableInternal is IERC173Internal {\n    error Ownable__NotOwner();\n    error Ownable__NotTransitiveOwner();\n}\n"
    },
    "@solidstate/contracts/access/ownable/ISafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IOwnable } from './IOwnable.sol';\n\ninterface ISafeOwnable is IOwnable {\n    /**\n     * @notice get the nominated owner who has permission to call acceptOwnership\n     */\n    function nomineeOwner() external view returns (address);\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function acceptOwnership() external;\n}\n"
    },
    "@solidstate/contracts/access/ownable/ISafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IOwnableInternal } from './IOwnableInternal.sol';\n\ninterface ISafeOwnableInternal is IOwnableInternal {\n    error SafeOwnable__NotNomineeOwner();\n}\n"
    },
    "@solidstate/contracts/access/ownable/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { IOwnable } from './IOwnable.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\n/**\n * @title Ownership access control based on ERC173\n */\nabstract contract Ownable is IOwnable, OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function owner() public view virtual returns (address) {\n        return _owner();\n    }\n\n    /**\n     * @inheritdoc IERC173\n     */\n    function transferOwnership(address account) public virtual onlyOwner {\n        _transferOwnership(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { AddressUtils } from '../../utils/AddressUtils.sol';\nimport { IOwnableInternal } from './IOwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\n\nabstract contract OwnableInternal is IOwnableInternal {\n    using AddressUtils for address;\n    using OwnableStorage for OwnableStorage.Layout;\n\n    modifier onlyOwner() {\n        if (msg.sender != _owner()) revert Ownable__NotOwner();\n        _;\n    }\n\n    modifier onlyTransitiveOwner() {\n        if (msg.sender != _transitiveOwner())\n            revert Ownable__NotTransitiveOwner();\n        _;\n    }\n\n    function _owner() internal view virtual returns (address) {\n        return OwnableStorage.layout().owner;\n    }\n\n    function _transitiveOwner() internal view virtual returns (address) {\n        address owner = _owner();\n\n        while (owner.isContract()) {\n            try IERC173(owner).owner() returns (address transitiveOwner) {\n                owner = transitiveOwner;\n            } catch {\n                return owner;\n            }\n        }\n\n        return owner;\n    }\n\n    function _transferOwnership(address account) internal virtual {\n        OwnableStorage.layout().setOwner(account);\n        emit OwnershipTransferred(msg.sender, account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary OwnableStorage {\n    struct Layout {\n        address owner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.Ownable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setOwner(Layout storage l, address owner) internal {\n        l.owner = owner;\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { Ownable, OwnableStorage } from './Ownable.sol';\nimport { ISafeOwnable } from './ISafeOwnable.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\n\n/**\n * @title Ownership access control based on ERC173 with ownership transfer safety check\n */\nabstract contract SafeOwnable is ISafeOwnable, Ownable, SafeOwnableInternal {\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function nomineeOwner() public view virtual returns (address) {\n        return _nomineeOwner();\n    }\n\n    /**\n     * @inheritdoc ISafeOwnable\n     */\n    function acceptOwnership() public virtual onlyNomineeOwner {\n        _acceptOwnership();\n    }\n\n    function _transferOwnership(\n        address account\n    ) internal virtual override(OwnableInternal, SafeOwnableInternal) {\n        super._transferOwnership(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ISafeOwnableInternal } from './ISafeOwnableInternal.sol';\nimport { OwnableInternal } from './OwnableInternal.sol';\nimport { OwnableStorage } from './OwnableStorage.sol';\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\n\nabstract contract SafeOwnableInternal is ISafeOwnableInternal, OwnableInternal {\n    using OwnableStorage for OwnableStorage.Layout;\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\n\n    modifier onlyNomineeOwner() {\n        if (msg.sender != _nomineeOwner())\n            revert SafeOwnable__NotNomineeOwner();\n        _;\n    }\n\n    /**\n     * @notice get the nominated owner who has permission to call acceptOwnership\n     */\n    function _nomineeOwner() internal view virtual returns (address) {\n        return SafeOwnableStorage.layout().nomineeOwner;\n    }\n\n    /**\n     * @notice accept transfer of contract ownership\n     */\n    function _acceptOwnership() internal virtual {\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\n        emit OwnershipTransferred(l.owner, msg.sender);\n        l.setOwner(msg.sender);\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\n    }\n\n    /**\n     * @notice set nominee owner, granting permission to call acceptOwnership\n     */\n    function _transferOwnership(address account) internal virtual override {\n        SafeOwnableStorage.layout().setNomineeOwner(account);\n    }\n}\n"
    },
    "@solidstate/contracts/access/ownable/SafeOwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary SafeOwnableStorage {\n    struct Layout {\n        address nomineeOwner;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.SafeOwnable');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\n        l.nomineeOwner = nomineeOwner;\n    }\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC165 interface registration interface\n * @dev see https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice query whether contract has registered support for given interface\n     * @param interfaceId interface id\n     * @return bool whether interface is supported\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC173Internal } from './IERC173Internal.sol';\n\n/**\n * @title Contract ownership standard interface\n * @dev see https://eips.ethereum.org/EIPS/eip-173\n */\ninterface IERC173 is IERC173Internal {\n    /**\n     * @notice get the ERC173 contract owner\n     * @return conrtact owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice transfer contract ownership to new account\n     * @param account address of new owner\n     */\n    function transferOwnership(address account) external;\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC173Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC173 interface needed by internal functions\n */\ninterface IERC173Internal {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from './IERC20Internal.sol';\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 is IERC20Internal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @notice grant approval to spender to spend tokens\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/interfaces/IERC20Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Partial ERC20 interface needed by internal functions\n */\ninterface IERC20Internal {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC165 } from '../interfaces/IERC165.sol';\nimport { ERC165Storage } from './ERC165Storage.sol';\n\n/**\n * @title ERC165 implementation\n */\nabstract contract ERC165 is IERC165 {\n    using ERC165Storage for ERC165Storage.Layout;\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\n    }\n}\n"
    },
    "@solidstate/contracts/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC165Storage {\n    error ERC165Storage__InvalidInterfaceId();\n\n    struct Layout {\n        mapping(bytes4 => bool) supportedInterfaces;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC165');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function isSupportedInterface(\n        Layout storage l,\n        bytes4 interfaceId\n    ) internal view returns (bool) {\n        return l.supportedInterfaces[interfaceId];\n    }\n\n    function setSupportedInterface(\n        Layout storage l,\n        bytes4 interfaceId,\n        bool status\n    ) internal {\n        if (interfaceId == 0xffffffff)\n            revert ERC165Storage__InvalidInterfaceId();\n        l.supportedInterfaces[interfaceId] = status;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/DiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { Proxy } from '../../Proxy.sol';\nimport { IDiamondBase } from './IDiamondBase.sol';\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy base contract\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\nabstract contract DiamondBase is IDiamondBase, Proxy {\n    /**\n     * @inheritdoc Proxy\n     */\n    function _getImplementation()\n        internal\n        view\n        virtual\n        override\n        returns (address implementation)\n    {\n        // inline storage layout retrieval uses less gas\n        DiamondBaseStorage.Layout storage l;\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n\n        implementation = address(bytes20(l.facets[msg.sig]));\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nlibrary DiamondBaseStorage {\n    struct Layout {\n        // function selector => (facet address, selector slot position)\n        mapping(bytes4 => bytes32) facets;\n        // total number of selectors registered\n        uint16 selectorCount;\n        // array of selector slots with 8 selectors per slot\n        mapping(uint256 => bytes32) selectorSlots;\n        address fallbackAddress;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.DiamondBase');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/base/IDiamondBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IProxy } from \"../../IProxy.sol\";\n\ninterface IDiamondBase is IProxy {}\n"
    },
    "@solidstate/contracts/proxy/diamond/fallback/DiamondFallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\nimport { DiamondBase } from '../base/DiamondBase.sol';\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondFallback } from './IDiamondFallback.sol';\n\n// TODO: DiamondFallback interface\n\n/**\n * @title Fallback feature for EIP-2535 \"Diamond\" proxy\n */\nabstract contract DiamondFallback is\n    IDiamondFallback,\n    OwnableInternal,\n    DiamondBase\n{\n    /**\n     * @inheritdoc IDiamondFallback\n     */\n    function getFallbackAddress()\n        external\n        view\n        returns (address fallbackAddress)\n    {\n        fallbackAddress = _getFallbackAddress();\n    }\n\n    /**\n     * @inheritdoc IDiamondFallback\n     */\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\n        _setFallbackAddress(fallbackAddress);\n    }\n\n    /**\n     * @inheritdoc DiamondBase\n     * @notice query custom fallback address is no implementation is found\n     */\n    function _getImplementation()\n        internal\n        view\n        virtual\n        override\n        returns (address implementation)\n    {\n        implementation = super._getImplementation();\n\n        if (implementation == address(0)) {\n            implementation = _getFallbackAddress();\n        }\n    }\n\n    /**\n     * @notice query the address of the fallback implementation\n     * @return fallbackAddress address of fallback implementation\n     */\n    function _getFallbackAddress()\n        internal\n        view\n        virtual\n        returns (address fallbackAddress)\n    {\n        fallbackAddress = DiamondBaseStorage.layout().fallbackAddress;\n    }\n\n    /**\n     * @notice set the address of the fallback implementation\n     * @param fallbackAddress address of fallback implementation\n     */\n    function _setFallbackAddress(address fallbackAddress) internal virtual {\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/fallback/IDiamondFallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IDiamondBase } from \"../base/IDiamondBase.sol\";\n\ninterface IDiamondFallback is IDiamondBase {\n    /**\n     * @notice query the address of the fallback implementation\n     * @return fallbackAddress address of fallback implementation\n     */\n    function getFallbackAddress()\n        external\n        view\n        returns (address fallbackAddress);\n\n    /**\n     * @notice set the address of the fallback implementation\n     * @param fallbackAddress address of fallback implementation\n     */\n    function setFallbackAddress(address fallbackAddress) external;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ISafeOwnable } from '../../access/ownable/ISafeOwnable.sol';\nimport { IERC165 } from '../../interfaces/IERC165.sol';\nimport { IDiamondBase } from './base/IDiamondBase.sol';\nimport { IDiamondFallback } from './fallback/IDiamondFallback.sol';\nimport { IDiamondReadable } from './readable/IDiamondReadable.sol';\nimport { IDiamondWritable } from './writable/IDiamondWritable.sol';\n\ninterface ISolidStateDiamond is\n    IDiamondBase,\n    IDiamondFallback,\n    IDiamondReadable,\n    IDiamondWritable,\n    ISafeOwnable,\n    IERC165\n{\n    receive() external payable;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondReadable } from './IDiamondReadable.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy introspection contract\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\n */\nabstract contract DiamondReadable is IDiamondReadable {\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facets() external view returns (Facet[] memory diamondFacets) {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        diamondFacets = new Facet[](l.selectorCount);\n\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (diamondFacets[facetIndex].target == facet) {\n                        diamondFacets[facetIndex].selectors[\n                            numFacetSelectors[facetIndex]\n                        ] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                diamondFacets[numFacets].target = facet;\n                diamondFacets[numFacets].selectors = new bytes4[](\n                    l.selectorCount\n                );\n                diamondFacets[numFacets].selectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\n\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n\n        // setting the number of facets\n        assembly {\n            mstore(diamondFacets, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetFunctionSelectors(\n        address facet\n    ) external view returns (bytes4[] memory selectors) {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        selectors = new bytes4[](l.selectorCount);\n\n        uint256 numSelectors;\n        uint256 selectorIndex;\n\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n\n                if (facet == address(bytes20(l.facets[selector]))) {\n                    selectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n\n        // set the number of selectors in the array\n        assembly {\n            mstore(selectors, numSelectors)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses)\n    {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        addresses = new address[](l.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\n            bytes32 slot = l.selectorSlots[slotIndex];\n\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n\n                if (selectorIndex > l.selectorCount) {\n                    break;\n                }\n\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(l.facets[selector]));\n\n                bool continueLoop;\n\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facet == addresses[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n\n                if (continueLoop) {\n                    continue;\n                }\n\n                addresses[numFacets] = facet;\n                numFacets++;\n            }\n        }\n\n        // set the number of facet addresses in the array\n        assembly {\n            mstore(addresses, numFacets)\n        }\n    }\n\n    /**\n     * @inheritdoc IDiamondReadable\n     */\n    function facetAddress(\n        bytes4 selector\n    ) external view returns (address facet) {\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Diamond proxy introspection interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondReadable {\n    struct Facet {\n        address target;\n        bytes4[] selectors;\n    }\n\n    /**\n     * @notice get all facets and their selectors\n     * @return diamondFacets array of structured facet data\n     */\n    function facets() external view returns (Facet[] memory diamondFacets);\n\n    /**\n     * @notice get all selectors for given facet address\n     * @param facet address of facet to query\n     * @return selectors array of function selectors\n     */\n    function facetFunctionSelectors(\n        address facet\n    ) external view returns (bytes4[] memory selectors);\n\n    /**\n     * @notice get addresses of all facets used by diamond\n     * @return addresses array of facet addresses\n     */\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory addresses);\n\n    /**\n     * @notice get the address of the facet associated with given selector\n     * @param selector function selector to query\n     * @return facet facet address (zero address if not found)\n     */\n    function facetAddress(\n        bytes4 selector\n    ) external view returns (address facet);\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IOwnable, Ownable, OwnableInternal, OwnableStorage } from '../../access/ownable/Ownable.sol';\nimport { ISafeOwnable, SafeOwnable } from '../../access/ownable/SafeOwnable.sol';\nimport { IERC173 } from '../../interfaces/IERC173.sol';\nimport { ERC165, IERC165, ERC165Storage } from '../../introspection/ERC165.sol';\nimport { DiamondBase, DiamondBaseStorage } from './base/DiamondBase.sol';\nimport { DiamondFallback, IDiamondFallback } from './fallback/DiamondFallback.sol';\nimport { DiamondReadable, IDiamondReadable } from './readable/DiamondReadable.sol';\nimport { DiamondWritable, IDiamondWritable } from './writable/DiamondWritable.sol';\nimport { ISolidStateDiamond } from './ISolidStateDiamond.sol';\n\n/**\n * @title SolidState \"Diamond\" proxy reference implementation\n */\nabstract contract SolidStateDiamond is\n    ISolidStateDiamond,\n    DiamondBase,\n    DiamondFallback,\n    DiamondReadable,\n    DiamondWritable,\n    SafeOwnable,\n    ERC165\n{\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\n    using ERC165Storage for ERC165Storage.Layout;\n    using OwnableStorage for OwnableStorage.Layout;\n\n    constructor() {\n        ERC165Storage.Layout storage erc165 = ERC165Storage.layout();\n        bytes4[] memory selectors = new bytes4[](12);\n        uint256 selectorIndex;\n\n        // register DiamondFallback\n\n        selectors[selectorIndex++] = IDiamondFallback\n            .getFallbackAddress\n            .selector;\n        selectors[selectorIndex++] = IDiamondFallback\n            .setFallbackAddress\n            .selector;\n\n        erc165.setSupportedInterface(type(IDiamondFallback).interfaceId, true);\n\n        // register DiamondWritable\n\n        selectors[selectorIndex++] = IDiamondWritable.diamondCut.selector;\n\n        erc165.setSupportedInterface(type(IDiamondWritable).interfaceId, true);\n\n        // register DiamondReadable\n\n        selectors[selectorIndex++] = IDiamondReadable.facets.selector;\n        selectors[selectorIndex++] = IDiamondReadable\n            .facetFunctionSelectors\n            .selector;\n        selectors[selectorIndex++] = IDiamondReadable.facetAddresses.selector;\n        selectors[selectorIndex++] = IDiamondReadable.facetAddress.selector;\n\n        erc165.setSupportedInterface(type(IDiamondReadable).interfaceId, true);\n\n        // register ERC165\n\n        selectors[selectorIndex++] = IERC165.supportsInterface.selector;\n\n        erc165.setSupportedInterface(type(IERC165).interfaceId, true);\n\n        // register SafeOwnable\n\n        selectors[selectorIndex++] = Ownable.owner.selector;\n        selectors[selectorIndex++] = SafeOwnable.nomineeOwner.selector;\n        selectors[selectorIndex++] = Ownable.transferOwnership.selector;\n        selectors[selectorIndex++] = SafeOwnable.acceptOwnership.selector;\n\n        erc165.setSupportedInterface(type(IERC173).interfaceId, true);\n\n        // diamond cut\n\n        FacetCut[] memory facetCuts = new FacetCut[](1);\n\n        facetCuts[0] = FacetCut({\n            target: address(this),\n            action: FacetCutAction.ADD,\n            selectors: selectors\n        });\n\n        _diamondCut(facetCuts, address(0), '');\n\n        // set owner\n\n        OwnableStorage.layout().setOwner(msg.sender);\n    }\n\n    receive() external payable {}\n\n    function _transferOwnership(\n        address account\n    ) internal virtual override(OwnableInternal, SafeOwnable) {\n        super._transferOwnership(account);\n    }\n\n    /**\n     * @inheritdoc DiamondFallback\n     */\n    function _getImplementation()\n        internal\n        view\n        override(DiamondBase, DiamondFallback)\n        returns (address implementation)\n    {\n        implementation = super._getImplementation();\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondWritable } from './IDiamondWritable.sol';\nimport { DiamondWritableInternal } from './DiamondWritableInternal.sol';\n\n/**\n * @title EIP-2535 \"Diamond\" proxy update contract\n */\nabstract contract DiamondWritable is\n    IDiamondWritable,\n    DiamondWritableInternal,\n    OwnableInternal\n{\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\n\n    /**\n     * @inheritdoc IDiamondWritable\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external onlyOwner {\n        _diamondCut(facetCuts, target, data);\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/DiamondWritableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\nimport { IDiamondWritableInternal } from './IDiamondWritableInternal.sol';\n\nabstract contract DiamondWritableInternal is IDiamondWritableInternal {\n    using AddressUtils for address;\n\n    bytes32 private constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 private constant CLEAR_SELECTOR_MASK =\n        bytes32(uint256(0xffffffff << 224));\n\n    /**\n     * @notice update functions callable on Diamond proxy\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional recipient of initialization delegatecall\n     * @param data optional initialization call data\n     */\n    function _diamondCut(\n        FacetCut[] memory facetCuts,\n        address target,\n        bytes memory data\n    ) internal {\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\n\n        unchecked {\n            uint256 originalSelectorCount = l.selectorCount;\n            uint256 selectorCount = originalSelectorCount;\n            bytes32 selectorSlot;\n\n            // Check if last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                // get last selectorSlot\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\n            }\n\n            for (uint256 i; i < facetCuts.length; i++) {\n                FacetCut memory facetCut = facetCuts[i];\n                FacetCutAction action = facetCut.action;\n\n                if (facetCut.selectors.length == 0)\n                    revert DiamondWritable__SelectorNotSpecified();\n\n                if (action == FacetCutAction.ADD) {\n                    (selectorCount, selectorSlot) = _addFacetSelectors(\n                        l,\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                } else if (action == FacetCutAction.REPLACE) {\n                    _replaceFacetSelectors(l, facetCut);\n                } else if (action == FacetCutAction.REMOVE) {\n                    (selectorCount, selectorSlot) = _removeFacetSelectors(\n                        l,\n                        selectorCount,\n                        selectorSlot,\n                        facetCut\n                    );\n                }\n            }\n\n            if (selectorCount != originalSelectorCount) {\n                l.selectorCount = uint16(selectorCount);\n            }\n\n            // If last selector slot is not full\n            if (selectorCount & 7 > 0) {\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\n            }\n\n            emit DiamondCut(facetCuts, target, data);\n            _initialize(target, data);\n        }\n    }\n\n    function _addFacetSelectors(\n        DiamondBaseStorage.Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            if (\n                facetCut.target != address(this) &&\n                !facetCut.target.isContract()\n            ) revert DiamondWritable__TargetHasNoCode();\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                if (address(bytes20(oldFacet)) != address(0))\n                    revert DiamondWritable__SelectorAlreadyAdded();\n\n                // add facet for selector\n                l.facets[selector] =\n                    bytes20(facetCut.target) |\n                    bytes32(selectorCount);\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\n\n                // clear selector position in slot and add selector\n                selectorSlot =\n                    (selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\n                    selectorSlot = 0;\n                }\n\n                selectorCount++;\n            }\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function _removeFacetSelectors(\n        DiamondBaseStorage.Layout storage l,\n        uint256 selectorCount,\n        bytes32 selectorSlot,\n        FacetCut memory facetCut\n    ) internal returns (uint256, bytes32) {\n        unchecked {\n            if (facetCut.target != address(0))\n                revert DiamondWritable__RemoveTargetNotZeroAddress();\n\n            uint256 selectorSlotCount = selectorCount >> 3;\n            uint256 selectorInSlotIndex = selectorCount & 7;\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n\n                if (address(bytes20(oldFacet)) == address(0))\n                    revert DiamondWritable__SelectorNotFound();\n\n                if (address(bytes20(oldFacet)) == address(this))\n                    revert DiamondWritable__SelectorIsImmutable();\n\n                if (selectorSlot == 0) {\n                    selectorSlotCount--;\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n\n                // adding a block here prevents stack too deep error\n                {\n                    // replace selector with last selector in l.facets\n                    lastSelector = bytes4(\n                        selectorSlot << (selectorInSlotIndex << 5)\n                    );\n\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        l.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(l.facets[lastSelector]);\n                    }\n\n                    delete l.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = l.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n\n                    // update storage with the modified slot\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    selectorSlot =\n                        (selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n\n                if (selectorInSlotIndex == 0) {\n                    delete l.selectorSlots[selectorSlotCount];\n                    selectorSlot = 0;\n                }\n            }\n\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\n\n            return (selectorCount, selectorSlot);\n        }\n    }\n\n    function _replaceFacetSelectors(\n        DiamondBaseStorage.Layout storage l,\n        FacetCut memory facetCut\n    ) internal {\n        unchecked {\n            if (!facetCut.target.isContract())\n                revert DiamondWritable__TargetHasNoCode();\n\n            for (uint256 i; i < facetCut.selectors.length; i++) {\n                bytes4 selector = facetCut.selectors[i];\n                bytes32 oldFacet = l.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n\n                if (oldFacetAddress == address(0))\n                    revert DiamondWritable__SelectorNotFound();\n                if (oldFacetAddress == address(this))\n                    revert DiamondWritable__SelectorIsImmutable();\n                if (oldFacetAddress == facetCut.target)\n                    revert DiamondWritable__ReplaceTargetIsIdentical();\n\n                // replace old facet address\n                l.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(facetCut.target);\n            }\n        }\n    }\n\n    function _initialize(address target, bytes memory data) private {\n        if ((target == address(0)) != (data.length == 0))\n            revert DiamondWritable__InvalidInitializationParameters();\n\n        if (target != address(0)) {\n            if (target != address(this)) {\n                if (!target.isContract())\n                    revert DiamondWritable__TargetHasNoCode();\n            }\n\n            (bool success, ) = target.delegatecall(data);\n\n            if (!success) {\n                assembly {\n                    returndatacopy(0, 0, returndatasize())\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/IDiamondWritable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IDiamondWritableInternal } from './IDiamondWritableInternal.sol';\n\n/**\n * @title Diamond proxy upgrade interface\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\n */\ninterface IDiamondWritable is IDiamondWritableInternal {\n    /**\n     * @notice update diamond facets and optionally execute arbitrary initialization function\n     * @param facetCuts array of structured Diamond facet update data\n     * @param target optional target of initialization delegatecall\n     * @param data optional initialization function call data\n     */\n    function diamondCut(\n        FacetCut[] calldata facetCuts,\n        address target,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@solidstate/contracts/proxy/diamond/writable/IDiamondWritableInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IDiamondWritableInternal {\n    enum FacetCutAction {\n        ADD,\n        REPLACE,\n        REMOVE\n    }\n\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\n\n    error DiamondWritable__InvalidInitializationParameters();\n    error DiamondWritable__RemoveTargetNotZeroAddress();\n    error DiamondWritable__ReplaceTargetIsIdentical();\n    error DiamondWritable__SelectorAlreadyAdded();\n    error DiamondWritable__SelectorIsImmutable();\n    error DiamondWritable__SelectorNotFound();\n    error DiamondWritable__SelectorNotSpecified();\n    error DiamondWritable__TargetHasNoCode();\n\n    struct FacetCut {\n        address target;\n        FacetCutAction action;\n        bytes4[] selectors;\n    }\n}\n"
    },
    "@solidstate/contracts/proxy/IProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\ninterface IProxy {\n    error Proxy__ImplementationIsNotContract();\n\n    fallback() external payable;\n}\n"
    },
    "@solidstate/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { AddressUtils } from '../utils/AddressUtils.sol';\nimport { IProxy } from './IProxy.sol';\n\n/**\n * @title Base proxy contract\n */\nabstract contract Proxy is IProxy {\n    using AddressUtils for address;\n\n    /**\n     * @notice delegate all calls to implementation contract\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\n     * @dev memory location in use by assembly may be unsafe in other contexts\n     */\n    fallback() external payable virtual {\n        address implementation = _getImplementation();\n\n        if (!implementation.isContract())\n            revert Proxy__ImplementationIsNotContract();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice get logic implementation address\n     * @return implementation address\n     */\n    function _getImplementation() internal virtual returns (address);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\nimport { IERC20Base } from './IERC20Base.sol';\nimport { ERC20BaseInternal } from './ERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 implementation, excluding optional extensions\n */\nabstract contract ERC20Base is IERC20Base, ERC20BaseInternal {\n    /**\n     * @inheritdoc IERC20\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply();\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function allowance(\n        address holder,\n        address spender\n    ) public view virtual returns (uint256) {\n        return _allowance(holder, spender);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function approve(\n        address spender,\n        uint256 amount\n    ) public virtual returns (bool) {\n        return _approve(msg.sender, spender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) public virtual returns (bool) {\n        return _transfer(msg.sender, recipient, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual returns (bool) {\n        return _transferFrom(holder, recipient, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from './IERC20BaseInternal.sol';\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\n\n/**\n * @title Base ERC20 internal functions, excluding optional extensions\n */\nabstract contract ERC20BaseInternal is IERC20BaseInternal {\n    /**\n     * @notice query the total minted token supply\n     * @return token supply\n     */\n    function _totalSupply() internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().totalSupply;\n    }\n\n    /**\n     * @notice query the token balance of given account\n     * @param account address to query\n     * @return token balance\n     */\n    function _balanceOf(\n        address account\n    ) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().balances[account];\n    }\n\n    /**\n     * @notice query the allowance granted from given holder to given spender\n     * @param holder approver of allowance\n     * @param spender recipient of allowance\n     * @return token allowance\n     */\n    function _allowance(\n        address holder,\n        address spender\n    ) internal view virtual returns (uint256) {\n        return ERC20BaseStorage.layout().allowances[holder][spender];\n    }\n\n    /**\n     * @notice enable spender to spend tokens on behalf of holder\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender recipient of allowance\n     * @param amount quantity of tokens approved for spending\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        if (holder == address(0)) revert ERC20Base__ApproveFromZeroAddress();\n        if (spender == address(0)) revert ERC20Base__ApproveToZeroAddress();\n\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\n\n        emit Approval(holder, spender, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice decrease spend amount granted by holder to spender\n     * @param holder address on whose behalf tokens may be spent\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     */\n    function _decreaseAllowance(\n        address holder,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = _allowance(holder, spender);\n\n        if (amount > allowance) revert ERC20Base__InsufficientAllowance();\n\n        unchecked {\n            _approve(holder, spender, allowance - amount);\n        }\n    }\n\n    /**\n     * @notice mint tokens for given account\n     * @param account recipient of minted tokens\n     * @param amount quantity of tokens minted\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert ERC20Base__MintToZeroAddress();\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        l.totalSupply += amount;\n        l.balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @notice burn tokens held by given account\n     * @param account holder of burned tokens\n     * @param amount quantity of tokens burned\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        if (account == address(0)) revert ERC20Base__BurnFromZeroAddress();\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 balance = l.balances[account];\n        if (amount > balance) revert ERC20Base__BurnExceedsBalance();\n        unchecked {\n            l.balances[account] = balance - amount;\n        }\n        l.totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @notice transfer tokens from holder to recipient\n     * @param holder owner of tokens to be transferred\n     * @param recipient beneficiary of transfer\n     * @param amount quantity of tokens transferred\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transfer(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        if (holder == address(0)) revert ERC20Base__TransferFromZeroAddress();\n        if (recipient == address(0)) revert ERC20Base__TransferToZeroAddress();\n\n        _beforeTokenTransfer(holder, recipient, amount);\n\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\n        uint256 holderBalance = l.balances[holder];\n        if (amount > holderBalance) revert ERC20Base__TransferExceedsBalance();\n        unchecked {\n            l.balances[holder] = holderBalance - amount;\n        }\n        l.balances[recipient] += amount;\n\n        emit Transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice transfer tokens to given recipient on behalf of given holder\n     * @param holder holder of tokens prior to transfer\n     * @param recipient beneficiary of token transfer\n     * @param amount quantity of tokens to transfer\n     * @return success status (always true; otherwise function should revert)\n     */\n    function _transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        _decreaseAllowance(holder, msg.sender, amount);\n\n        _transfer(holder, recipient, amount);\n\n        return true;\n    }\n\n    /**\n     * @notice ERC20 hook, called before all transfers including mint and burn\n     * @dev function should be overridden and new implementation must call super\n     * @param from sender of tokens\n     * @param to receiver of tokens\n     * @param amount quantity of tokens transferred\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20BaseStorage {\n    struct Layout {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowances;\n        uint256 totalSupply;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Base');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/IERC20Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20 } from '../../../interfaces/IERC20.sol';\nimport { IERC20BaseInternal } from './IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20Base is IERC20BaseInternal, IERC20 {\n\n}\n"
    },
    "@solidstate/contracts/token/ERC20/base/IERC20BaseInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Internal } from '../../../interfaces/IERC20Internal.sol';\n\n/**\n * @title ERC20 base interface\n */\ninterface IERC20BaseInternal is IERC20Internal {\n    error ERC20Base__ApproveFromZeroAddress();\n    error ERC20Base__ApproveToZeroAddress();\n    error ERC20Base__BurnExceedsBalance();\n    error ERC20Base__BurnFromZeroAddress();\n    error ERC20Base__InsufficientAllowance();\n    error ERC20Base__MintToZeroAddress();\n    error ERC20Base__TransferExceedsBalance();\n    error ERC20Base__TransferFromZeroAddress();\n    error ERC20Base__TransferToZeroAddress();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Extended } from './IERC20Extended.sol';\nimport { ERC20ExtendedInternal } from './ERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20Extended is IERC20Extended, ERC20ExtendedInternal {\n    /**\n     * @inheritdoc IERC20Extended\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        return _increaseAllowance(spender, amount);\n    }\n\n    /**\n     * @inheritdoc IERC20Extended\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool) {\n        return _decreaseAllowance(spender, amount);\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/ERC20ExtendedInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { ERC20BaseInternal, ERC20BaseStorage } from '../base/ERC20Base.sol';\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 safe approval extensions\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\n */\nabstract contract ERC20ExtendedInternal is\n    ERC20BaseInternal,\n    IERC20ExtendedInternal\n{\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function _increaseAllowance(\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        uint256 allowance = _allowance(msg.sender, spender);\n\n        unchecked {\n            if (allowance > allowance + amount)\n                revert ERC20Extended__ExcessiveAllowance();\n\n            return _approve(msg.sender, spender, allowance + amount);\n        }\n    }\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function _decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) internal virtual returns (bool) {\n        _decreaseAllowance(msg.sender, spender, amount);\n\n        return true;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20ExtendedInternal } from './IERC20ExtendedInternal.sol';\n\n/**\n * @title ERC20 extended interface\n */\ninterface IERC20Extended is IERC20ExtendedInternal {\n    /**\n     * @notice increase spend amount granted to spender\n     * @param spender address whose allowance to increase\n     * @param amount quantity by which to increase allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function increaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @notice decrease spend amount granted to spender\n     * @param spender address whose allowance to decrease\n     * @param amount quantity by which to decrease allowance\n     * @return success status (always true; otherwise function will revert)\n     */\n    function decreaseAllowance(\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/extended/IERC20ExtendedInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20BaseInternal } from '../base/IERC20BaseInternal.sol';\n\n/**\n * @title ERC20 extended internal interface\n */\ninterface IERC20ExtendedInternal is IERC20BaseInternal {\n    error ERC20Extended__ExcessiveAllowance();\n    error ERC20Extended__InsufficientAllowance();\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20Metadata } from './IERC20Metadata.sol';\nimport { ERC20MetadataInternal } from './ERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata extensions\n */\nabstract contract ERC20Metadata is IERC20Metadata, ERC20MetadataInternal {\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function name() external view returns (string memory) {\n        return _name();\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol();\n    }\n\n    /**\n     * @inheritdoc IERC20Metadata\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals();\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\nimport { ERC20MetadataStorage } from './ERC20MetadataStorage.sol';\n\n/**\n * @title ERC20Metadata internal functions\n */\nabstract contract ERC20MetadataInternal is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function _name() internal view virtual returns (string memory) {\n        return ERC20MetadataStorage.layout().name;\n    }\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function _symbol() internal view virtual returns (string memory) {\n        return ERC20MetadataStorage.layout().symbol;\n    }\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function _decimals() internal view virtual returns (uint8) {\n        return ERC20MetadataStorage.layout().decimals;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nlibrary ERC20MetadataStorage {\n    struct Layout {\n        string name;\n        string symbol;\n        uint8 decimals;\n    }\n\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n\n    function setName(Layout storage l, string memory name) internal {\n        l.name = name;\n    }\n\n    function setSymbol(Layout storage l, string memory symbol) internal {\n        l.symbol = symbol;\n    }\n\n    function setDecimals(Layout storage l, uint8 decimals) internal {\n        l.decimals = decimals;\n    }\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { IERC20MetadataInternal } from './IERC20MetadataInternal.sol';\n\n/**\n * @title ERC20 metadata interface\n */\ninterface IERC20Metadata is IERC20MetadataInternal {\n    /**\n     * @notice return token name\n     * @return token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @notice return token symbol\n     * @return token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice return token decimals, generally used only for display purposes\n     * @return token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@solidstate/contracts/token/ERC20/metadata/IERC20MetadataInternal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title ERC20 metadata internal interface\n */\ninterface IERC20MetadataInternal {\n\n}\n"
    },
    "@solidstate/contracts/utils/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\nimport { UintUtils } from './UintUtils.sol';\n\nlibrary AddressUtils {\n    using UintUtils for uint256;\n\n    error AddressUtils__InsufficientBalance();\n    error AddressUtils__NotContract();\n    error AddressUtils__SendValueFailed();\n\n    function toString(address account) internal pure returns (string memory) {\n        return uint256(uint160(account)).toHexString(20);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function sendValue(address payable account, uint256 amount) internal {\n        (bool success, ) = account.call{ value: amount }('');\n        if (!success) revert AddressUtils__SendValueFailed();\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data\n    ) internal returns (bytes memory) {\n        return\n            functionCall(target, data, 'AddressUtils: failed low-level call');\n    }\n\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory error\n    ) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, error);\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'AddressUtils: failed low-level call with value'\n            );\n    }\n\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) internal returns (bytes memory) {\n        if (value > address(this).balance)\n            revert AddressUtils__InsufficientBalance();\n        return _functionCallWithValue(target, data, value, error);\n    }\n\n    /**\n     * @notice execute arbitrary external call with limited gas usage and amount of copied return data\n     * @dev derived from https://github.com/nomad-xyz/ExcessivelySafeCall (MIT License)\n     * @param target recipient of call\n     * @param gasAmount gas allowance for call\n     * @param value native token value to include in call\n     * @param maxCopy maximum number of bytes to copy from return data\n     * @param data encoded call data\n     * @return success whether call is successful\n     * @return returnData copied return data\n     */\n    function excessivelySafeCall(\n        address target,\n        uint256 gasAmount,\n        uint256 value,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bytes memory returnData) {\n        returnData = new bytes(maxCopy);\n\n        assembly {\n            // execute external call via assembly to avoid automatic copying of return data\n            success := call(\n                gasAmount,\n                target,\n                value,\n                add(data, 0x20),\n                mload(data),\n                0,\n                0\n            )\n\n            // determine whether to limit amount of data to copy\n            let toCopy := returndatasize()\n\n            if gt(toCopy, maxCopy) {\n                toCopy := maxCopy\n            }\n\n            // store the length of the copied bytes\n            mstore(returnData, toCopy)\n\n            // copy the bytes from returndata[0:toCopy]\n            returndatacopy(add(returnData, 0x20), 0, toCopy)\n        }\n    }\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory error\n    ) private returns (bytes memory) {\n        if (!isContract(target)) revert AddressUtils__NotContract();\n\n        (bool success, bytes memory returnData) = target.call{ value: value }(\n            data\n        );\n\n        if (success) {\n            return returnData;\n        } else if (returnData.length > 0) {\n            assembly {\n                let returnData_size := mload(returnData)\n                revert(add(32, returnData), returnData_size)\n            }\n        } else {\n            revert(error);\n        }\n    }\n}\n"
    },
    "@solidstate/contracts/utils/UintUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title utility functions for uint256 operations\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\n */\nlibrary UintUtils {\n    error UintUtils__InsufficientHexLength();\n\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\n\n    function add(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? sub(a, -b) : a + uint256(b);\n    }\n\n    function sub(uint256 a, int256 b) internal pure returns (uint256) {\n        return b < 0 ? add(a, -b) : a - uint256(b);\n    }\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0';\n        }\n\n        uint256 temp = value;\n        uint256 digits;\n\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n\n        bytes memory buffer = new bytes(digits);\n\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n\n        return string(buffer);\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return '0x00';\n        }\n\n        uint256 length = 0;\n\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\n            unchecked {\n                length++;\n            }\n        }\n\n        return toHexString(value, length);\n    }\n\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n\n        unchecked {\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\n                value >>= 4;\n            }\n        }\n\n        if (value != 0) revert UintUtils__InsufficientHexLength();\n\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/CryptoGrow/CollateralEscrow.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@solidstate/contracts/interfaces/IERC20.sol\";\n\ncontract CollateralEscrow {\n  struct AppStorage {\n    address owner;\n  }\n  AppStorage internal s;\n\n  constructor(address _hTokenContract) {\n    s.owner = msg.sender;\n    approveCryptoGrowDiamond(_hTokenContract);\n  }\n\n  function approveCryptoGrowDiamond(address _hTokenContract) public {\n    require(msg.sender == s.owner, \"CollateralEscrow: Not owner of contract\");\n    require(\n      IERC20(_hTokenContract).approve(s.owner, type(uint256).max),\n      \"CollateralEscrow: token not approved for transfer\"\n    );\n  }\n}\n"
    },
    "contracts/CryptoGrow/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport {SolidStateDiamond} from \"@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol\";\n\ncontract Diamond is SolidStateDiamond {}\n"
    },
    "contracts/CryptoGrow/facets/HarvestFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ERC20Base} from \"@solidstate/contracts/token/ERC20/base/ERC20Base.sol\";\nimport {ERC20Extended} from \"@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol\";\nimport {ERC20Metadata} from \"@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol\";\n\ncontract HRVSTFacet is ERC20Base, ERC20Extended, ERC20Metadata {\n  function mint() external {\n    uint256 amount = 1e18;\n    _mint(msg.sender, amount);\n  }\n\n  function mintTo(address _user) external {\n    uint256 amount = 1e18;\n    _mint(_user, amount);\n  }\n}\n"
    },
    "contracts/CryptoGrow/InitDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ILink} from \"./interfaces/ILink.sol\";\n\nimport {LibAppStorage} from \"./libraries/LibAppStorage.sol\";\nimport {ERC20MetadataStorage} from \"@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol\";\n\ncontract InitDiamond {\n  struct Args {\n    address dao;\n    address daoTreasury;\n    address cryptoGrow;\n    address rarityFarming;\n    address hrvstContract;\n    bytes32 chainlinkKeyHash;\n    uint256 chainlinkFee;\n    address vrfCoordinator;\n    address linkAddress;\n    address childChainManager;\n    string name;\n    string symbol;\n  }\n\n  function init(Args memory _args) external {\n    LibAppStorage.Layout storage appLayout = LibAppStorage.layout();\n    appLayout.dao = _args.dao;\n    appLayout.daoTreasury = _args.daoTreasury;\n    appLayout.rarityFarming = _args.rarityFarming;\n    appLayout.cryptoGrow = _args.cryptoGrow;\n    appLayout.itemsBaseUri = \"https://cryptogrow.com/metadata/items/\";\n    appLayout.childChainManager = _args.childChainManager;\n\n    appLayout.domainSeparator = _domainSeparator(\"cryptoGrowDiamond\", \"V1\");\n\n    appLayout.hrvstContract = _args.hrvstContract;\n    appLayout.keyHash = _args.chainlinkKeyHash;\n    appLayout.fee = uint144(_args.chainlinkFee);\n    appLayout.vrfCoordinator = _args.vrfCoordinator;\n    appLayout.link = ILink(_args.linkAddress);\n\n    appLayout.listingFeeInWei = 1e17;\n\n    ERC20MetadataStorage.Layout storage erc20Layout = ERC20MetadataStorage.layout();\n    erc20Layout.name = _args.name;\n    erc20Layout.symbol = _args.symbol;\n    erc20Layout.decimals = 18;\n  }\n\n  function _domainSeparator(\n    string memory name,\n    string memory version\n  ) internal view returns (bytes32) {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    bytes32 typeHash = keccak256(\n      \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    return keccak256(abi.encode(typeHash, hashedName, hashedVersion, block.chainid, address(this)));\n  }\n}\n"
    },
    "contracts/CryptoGrow/interfaces/ILink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILink {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/CryptoGrow/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ILink} from \"../interfaces/ILink.sol\";\n\nlibrary LibAppStorage {\n  struct Layout {\n    address dao;\n    address daoTreasury;\n    address cryptoGrow;\n    address rarityFarming;\n    address hrvstContract;\n    address vrfCoordinator;\n    address childChainManager;\n    string itemsBaseUri;\n    bytes32 domainSeparator;\n    bytes32 keyHash;\n    uint144 fee;\n    ILink link;\n    uint256 listingFeeInWei;\n  }\n\n  bytes32 internal constant STORAGE_SLOT = keccak256(\"cryptogrow.contracts.storage.App\");\n\n  function layout() internal pure returns (Layout storage l) {\n    bytes32 slot = STORAGE_SLOT;\n    assembly {\n      l.slot := slot\n    }\n  }\n\n  function setDomainSeparator(string memory name, string memory version) public {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    bytes32 typeHash = keccak256(\n      \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    layout().domainSeparator = keccak256(\n      abi.encode(typeHash, hashedName, hashedVersion, block.chainid, address(this))\n    );\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}